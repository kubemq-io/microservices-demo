// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kubemq_go.proto

package pb

import (
	"context"
	"github.com/gogo/protobuf/proto"
	"google.golang.org/grpc"

	"fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	"math"

	"strconv"

	"bytes"

	"reflect"
	"strings"

	"io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Subscribe_SubscribeType int32

const (
	SubscribeTypeUndefined Subscribe_SubscribeType = 0
	Events                 Subscribe_SubscribeType = 1
	EventsStore            Subscribe_SubscribeType = 2
	Commands               Subscribe_SubscribeType = 3
	Queries                Subscribe_SubscribeType = 4
)

var Subscribe_SubscribeType_name = map[int32]string{
	0: "SubscribeTypeUndefined",
	1: "Events",
	2: "EventsStore",
	3: "Commands",
	4: "Queries",
}
var Subscribe_SubscribeType_value = map[string]int32{
	"SubscribeTypeUndefined": 0,
	"Events":                 1,
	"EventsStore":            2,
	"Commands":               3,
	"Queries":                4,
}

func (Subscribe_SubscribeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_92930a2662292ba9, []int{4, 0}
}

type Subscribe_EventsStoreType int32

const (
	EventsStoreTypeUndefined Subscribe_EventsStoreType = 0
	StartNewOnly             Subscribe_EventsStoreType = 1
	StartFromFirst           Subscribe_EventsStoreType = 2
	StartFromLast            Subscribe_EventsStoreType = 3
	StartAtSequence          Subscribe_EventsStoreType = 4
	StartAtTime              Subscribe_EventsStoreType = 5
	StartAtTimeDelta         Subscribe_EventsStoreType = 6
)

var Subscribe_EventsStoreType_name = map[int32]string{
	0: "EventsStoreTypeUndefined",
	1: "StartNewOnly",
	2: "StartFromFirst",
	3: "StartFromLast",
	4: "StartAtSequence",
	5: "StartAtTime",
	6: "StartAtTimeDelta",
}
var Subscribe_EventsStoreType_value = map[string]int32{
	"EventsStoreTypeUndefined": 0,
	"StartNewOnly":             1,
	"StartFromFirst":           2,
	"StartFromLast":            3,
	"StartAtSequence":          4,
	"StartAtTime":              5,
	"StartAtTimeDelta":         6,
}

func (Subscribe_EventsStoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_92930a2662292ba9, []int{4, 1}
}

type Request_RequestType int32

const (
	RequestTypeUnknown Request_RequestType = 0
	Command            Request_RequestType = 1
	Query              Request_RequestType = 2
)

var Request_RequestType_name = map[int32]string{
	0: "RequestTypeUnknown",
	1: "Command",
	2: "Query",
}
var Request_RequestType_value = map[string]int32{
	"RequestTypeUnknown": 0,
	"Command":            1,
	"Query":              2,
}

func (Request_RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_92930a2662292ba9, []int{5, 0}
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_92930a2662292ba9, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(dst, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Result struct {
	EventID              string   `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Sent                 bool     `protobuf:"varint,2,opt,name=Sent,proto3" json:"Sent,omitempty"`
	Error                string   `protobuf:"bytes,3,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Result) Reset()      { *m = Result{} }
func (*Result) ProtoMessage() {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_92930a2662292ba9, []int{1}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(dst, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *Result) GetSent() bool {
	if m != nil {
		return m.Sent
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Event struct {
	EventID              string   `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string   `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string   `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte   `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	Store                bool     `protobuf:"varint,6,opt,name=Store,proto3" json:"Store,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()      { *m = Event{} }
func (*Event) ProtoMessage() {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_92930a2662292ba9, []int{2}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(dst, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *Event) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Event) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Event) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Event) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Event) GetStore() bool {
	if m != nil {
		return m.Store
	}
	return false
}

type EventReceive struct {
	EventID              string   `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Channel              string   `protobuf:"bytes,2,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string   `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte   `protobuf:"bytes,4,opt,name=Body,proto3" json:"Body,omitempty"`
	Timestamp            int64    `protobuf:"varint,5,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Sequence             uint64   `protobuf:"varint,6,opt,name=Sequence,proto3" json:"Sequence,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventReceive) Reset()      { *m = EventReceive{} }
func (*EventReceive) ProtoMessage() {}
func (*EventReceive) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_92930a2662292ba9, []int{3}
}
func (m *EventReceive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReceive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReceive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EventReceive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReceive.Merge(dst, src)
}
func (m *EventReceive) XXX_Size() int {
	return m.Size()
}
func (m *EventReceive) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReceive.DiscardUnknown(m)
}

var xxx_messageInfo_EventReceive proto.InternalMessageInfo

func (m *EventReceive) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *EventReceive) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *EventReceive) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *EventReceive) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *EventReceive) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EventReceive) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

type Subscribe struct {
	SubscribeTypeData    Subscribe_SubscribeType   `protobuf:"varint,1,opt,name=SubscribeTypeData,proto3,enum=kubemq.Subscribe_SubscribeType" json:"SubscribeTypeData,omitempty"`
	ClientID             string                    `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string                    `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Group                string                    `protobuf:"bytes,4,opt,name=Group,proto3" json:"Group,omitempty"`
	EventsStoreTypeData  Subscribe_EventsStoreType `protobuf:"varint,5,opt,name=EventsStoreTypeData,proto3,enum=kubemq.Subscribe_EventsStoreType" json:"EventsStoreTypeData,omitempty"`
	EventsStoreTypeValue int64                     `protobuf:"varint,6,opt,name=EventsStoreTypeValue,proto3" json:"EventsStoreTypeValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *Subscribe) Reset()      { *m = Subscribe{} }
func (*Subscribe) ProtoMessage() {}
func (*Subscribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_92930a2662292ba9, []int{4}
}
func (m *Subscribe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subscribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subscribe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Subscribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscribe.Merge(dst, src)
}
func (m *Subscribe) XXX_Size() int {
	return m.Size()
}
func (m *Subscribe) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscribe.DiscardUnknown(m)
}

var xxx_messageInfo_Subscribe proto.InternalMessageInfo

func (m *Subscribe) GetSubscribeTypeData() Subscribe_SubscribeType {
	if m != nil {
		return m.SubscribeTypeData
	}
	return SubscribeTypeUndefined
}

func (m *Subscribe) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Subscribe) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Subscribe) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Subscribe) GetEventsStoreTypeData() Subscribe_EventsStoreType {
	if m != nil {
		return m.EventsStoreTypeData
	}
	return EventsStoreTypeUndefined
}

func (m *Subscribe) GetEventsStoreTypeValue() int64 {
	if m != nil {
		return m.EventsStoreTypeValue
	}
	return 0
}

type Request struct {
	RequestID            string              `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	RequestTypeData      Request_RequestType `protobuf:"varint,2,opt,name=RequestTypeData,proto3,enum=kubemq.Request_RequestType" json:"RequestTypeData,omitempty"`
	ClientID             string              `protobuf:"bytes,3,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string              `protobuf:"bytes,4,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string              `protobuf:"bytes,5,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte              `protobuf:"bytes,6,opt,name=Body,proto3" json:"Body,omitempty"`
	ReplyChannel         string              `protobuf:"bytes,7,opt,name=ReplyChannel,proto3" json:"ReplyChannel,omitempty"`
	Timeout              int32               `protobuf:"varint,8,opt,name=Timeout,proto3" json:"Timeout,omitempty"`
	CacheKey             string              `protobuf:"bytes,9,opt,name=CacheKey,proto3" json:"CacheKey,omitempty"`
	CacheTTL             int32               `protobuf:"varint,10,opt,name=CacheTTL,proto3" json:"CacheTTL,omitempty"`
	Span                 []byte              `protobuf:"bytes,11,opt,name=Span,proto3" json:"Span,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Request) Reset()      { *m = Request{} }
func (*Request) ProtoMessage() {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_92930a2662292ba9, []int{5}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(dst, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Request) GetRequestTypeData() Request_RequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return RequestTypeUnknown
}

func (m *Request) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Request) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Request) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Request) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Request) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Request) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *Request) GetCacheKey() string {
	if m != nil {
		return m.CacheKey
	}
	return ""
}

func (m *Request) GetCacheTTL() int32 {
	if m != nil {
		return m.CacheTTL
	}
	return 0
}

func (m *Request) GetSpan() []byte {
	if m != nil {
		return m.Span
	}
	return nil
}

type Response struct {
	ClientID             string   `protobuf:"bytes,1,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	RequestID            string   `protobuf:"bytes,2,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ReplyChannel         string   `protobuf:"bytes,3,opt,name=ReplyChannel,proto3" json:"ReplyChannel,omitempty"`
	Metadata             string   `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte   `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	CacheHit             bool     `protobuf:"varint,6,opt,name=CacheHit,proto3" json:"CacheHit,omitempty"`
	Timestamp            int64    `protobuf:"varint,7,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Executed             bool     `protobuf:"varint,8,opt,name=Executed,proto3" json:"Executed,omitempty"`
	Error                string   `protobuf:"bytes,9,opt,name=Error,proto3" json:"Error,omitempty"`
	Span                 []byte   `protobuf:"bytes,10,opt,name=Span,proto3" json:"Span,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()      { *m = Response{} }
func (*Response) ProtoMessage() {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_92930a2662292ba9, []int{6}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(dst, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Response) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Response) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Response) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Response) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Response) GetCacheHit() bool {
	if m != nil {
		return m.CacheHit
	}
	return false
}

func (m *Response) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Response) GetExecuted() bool {
	if m != nil {
		return m.Executed
	}
	return false
}

func (m *Response) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Response) GetSpan() []byte {
	if m != nil {
		return m.Span
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "kubemq.Empty")
	proto.RegisterType((*Result)(nil), "kubemq.Result")
	proto.RegisterType((*Event)(nil), "kubemq.Event")
	proto.RegisterType((*EventReceive)(nil), "kubemq.EventReceive")
	proto.RegisterType((*Subscribe)(nil), "kubemq.Subscribe")
	proto.RegisterType((*Request)(nil), "kubemq.Request")
	proto.RegisterType((*Response)(nil), "kubemq.Response")
	proto.RegisterEnum("kubemq.Subscribe_SubscribeType", Subscribe_SubscribeType_name, Subscribe_SubscribeType_value)
	proto.RegisterEnum("kubemq.Subscribe_EventsStoreType", Subscribe_EventsStoreType_name, Subscribe_EventsStoreType_value)
	proto.RegisterEnum("kubemq.Request_RequestType", Request_RequestType_name, Request_RequestType_value)
}
func (x Subscribe_SubscribeType) String() string {
	s, ok := Subscribe_SubscribeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Subscribe_EventsStoreType) String() string {
	s, ok := Subscribe_EventsStoreType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Request_RequestType) String() string {
	s, ok := Request_RequestType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Result) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Result)
	if !ok {
		that2, ok := that.(Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.Sent != that1.Sent {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *Event) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Event)
	if !ok {
		that2, ok := that.(Event)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.Store != that1.Store {
		return false
	}
	return true
}
func (this *EventReceive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventReceive)
	if !ok {
		that2, ok := that.(EventReceive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Sequence != that1.Sequence {
		return false
	}
	return true
}
func (this *Subscribe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Subscribe)
	if !ok {
		that2, ok := that.(Subscribe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubscribeTypeData != that1.SubscribeTypeData {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Group != that1.Group {
		return false
	}
	if this.EventsStoreTypeData != that1.EventsStoreTypeData {
		return false
	}
	if this.EventsStoreTypeValue != that1.EventsStoreTypeValue {
		return false
	}
	return true
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.RequestTypeData != that1.RequestTypeData {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.ReplyChannel != that1.ReplyChannel {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if this.CacheKey != that1.CacheKey {
		return false
	}
	if this.CacheTTL != that1.CacheTTL {
		return false
	}
	if !bytes.Equal(this.Span, that1.Span) {
		return false
	}
	return true
}
func (this *Response) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Response)
	if !ok {
		that2, ok := that.(Response)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ReplyChannel != that1.ReplyChannel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.CacheHit != that1.CacheHit {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Executed != that1.Executed {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.Span, that1.Span) {
		return false
	}
	return true
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&kubemq.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&kubemq.Result{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "Sent: "+fmt.Sprintf("%#v", this.Sent)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Event) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.Event{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "Store: "+fmt.Sprintf("%#v", this.Store)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EventReceive) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.EventReceive{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Sequence: "+fmt.Sprintf("%#v", this.Sequence)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Subscribe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.Subscribe{")
	s = append(s, "SubscribeTypeData: "+fmt.Sprintf("%#v", this.SubscribeTypeData)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	s = append(s, "EventsStoreTypeData: "+fmt.Sprintf("%#v", this.EventsStoreTypeData)+",\n")
	s = append(s, "EventsStoreTypeValue: "+fmt.Sprintf("%#v", this.EventsStoreTypeValue)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Request) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&kubemq.Request{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "RequestTypeData: "+fmt.Sprintf("%#v", this.RequestTypeData)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "ReplyChannel: "+fmt.Sprintf("%#v", this.ReplyChannel)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "CacheKey: "+fmt.Sprintf("%#v", this.CacheKey)+",\n")
	s = append(s, "CacheTTL: "+fmt.Sprintf("%#v", this.CacheTTL)+",\n")
	s = append(s, "Span: "+fmt.Sprintf("%#v", this.Span)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Response) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&kubemq.Response{")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ReplyChannel: "+fmt.Sprintf("%#v", this.ReplyChannel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "CacheHit: "+fmt.Sprintf("%#v", this.CacheHit)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Executed: "+fmt.Sprintf("%#v", this.Executed)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "Span: "+fmt.Sprintf("%#v", this.Span)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringKubemqGo(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Kubemq service

type KubemqClient interface {
	SendEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Result, error)
	SendEventsStream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_SendEventsStreamClient, error)
	SubscribeToEvents(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToEventsClient, error)
	SubscribeToRequests(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToRequestsClient, error)
	SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error)
}

type kubemqClient struct {
	cc *grpc.ClientConn
}

func NewKubemqClient(cc *grpc.ClientConn) KubemqClient {
	return &kubemqClient{cc}
}

func (c *kubemqClient) SendEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendEventsStream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_SendEventsStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[0], "/kubemq.kubemq/SendEventsStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSendEventsStreamClient{stream}
	return x, nil
}

type Kubemq_SendEventsStreamClient interface {
	Send(*Event) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type kubemqSendEventsStreamClient struct {
	grpc.ClientStream
}

func (x *kubemqSendEventsStreamClient) Send(m *Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqSendEventsStreamClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SubscribeToEvents(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[1], "/kubemq.kubemq/SubscribeToEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSubscribeToEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Kubemq_SubscribeToEventsClient interface {
	Recv() (*EventReceive, error)
	grpc.ClientStream
}

type kubemqSubscribeToEventsClient struct {
	grpc.ClientStream
}

func (x *kubemqSubscribeToEventsClient) Recv() (*EventReceive, error) {
	m := new(EventReceive)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SubscribeToRequests(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToRequestsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[2], "/kubemq.kubemq/SubscribeToRequests", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSubscribeToRequestsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Kubemq_SubscribeToRequestsClient interface {
	Recv() (*Request, error)
	grpc.ClientStream
}

type kubemqSubscribeToRequestsClient struct {
	grpc.ClientStream
}

func (x *kubemqSubscribeToRequestsClient) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendResponse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Kubemq service

type KubemqServer interface {
	SendEvent(context.Context, *Event) (*Result, error)
	SendEventsStream(Kubemq_SendEventsStreamServer) error
	SubscribeToEvents(*Subscribe, Kubemq_SubscribeToEventsServer) error
	SubscribeToRequests(*Subscribe, Kubemq_SubscribeToRequestsServer) error
	SendRequest(context.Context, *Request) (*Response, error)
	SendResponse(context.Context, *Response) (*Empty, error)
}

func RegisterKubemqServer(s *grpc.Server, srv KubemqServer) {
	s.RegisterService(&_Kubemq_serviceDesc, srv)
}

func _Kubemq_SendEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendEventsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).SendEventsStream(&kubemqSendEventsStreamServer{stream})
}

type Kubemq_SendEventsStreamServer interface {
	Send(*Result) error
	Recv() (*Event, error)
	grpc.ServerStream
}

type kubemqSendEventsStreamServer struct {
	grpc.ServerStream
}

func (x *kubemqSendEventsStreamServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqSendEventsStreamServer) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_SubscribeToEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubemqServer).SubscribeToEvents(m, &kubemqSubscribeToEventsServer{stream})
}

type Kubemq_SubscribeToEventsServer interface {
	Send(*EventReceive) error
	grpc.ServerStream
}

type kubemqSubscribeToEventsServer struct {
	grpc.ServerStream
}

func (x *kubemqSubscribeToEventsServer) Send(m *EventReceive) error {
	return x.ServerStream.SendMsg(m)
}

func _Kubemq_SubscribeToRequests_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubemqServer).SubscribeToRequests(m, &kubemqSubscribeToRequestsServer{stream})
}

type Kubemq_SubscribeToRequestsServer interface {
	Send(*Request) error
	grpc.ServerStream
}

type kubemqSubscribeToRequestsServer struct {
	grpc.ServerStream
}

func (x *kubemqSubscribeToRequestsServer) Send(m *Request) error {
	return x.ServerStream.SendMsg(m)
}

func _Kubemq_SendRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendRequest(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendResponse(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

var _Kubemq_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kubemq.kubemq",
	HandlerType: (*KubemqServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendEvent",
			Handler:    _Kubemq_SendEvent_Handler,
		},
		{
			MethodName: "SendRequest",
			Handler:    _Kubemq_SendRequest_Handler,
		},
		{
			MethodName: "SendResponse",
			Handler:    _Kubemq_SendResponse_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendEventsStream",
			Handler:       _Kubemq_SendEventsStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeToEvents",
			Handler:       _Kubemq_SubscribeToEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToRequests",
			Handler:       _Kubemq_SubscribeToRequests_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "kubemq_go.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if m.Sent {
		dAtA[i] = 0x10
		i++
		if m.Sent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.Store {
		dAtA[i] = 0x30
		i++
		if m.Store {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *EventReceive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReceive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Sequence))
	}
	return i, nil
}

func (m *Subscribe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subscribe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubscribeTypeData != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SubscribeTypeData))
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if m.EventsStoreTypeData != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.EventsStoreTypeData))
	}
	if m.EventsStoreTypeValue != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.EventsStoreTypeValue))
	}
	return i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.RequestTypeData != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RequestTypeData))
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.ReplyChannel) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReplyChannel)))
		i += copy(dAtA[i:], m.ReplyChannel)
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timeout))
	}
	if len(m.CacheKey) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.CacheKey)))
		i += copy(dAtA[i:], m.CacheKey)
	}
	if m.CacheTTL != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.CacheTTL))
	}
	if len(m.Span) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Span)))
		i += copy(dAtA[i:], m.Span)
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.RequestID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ReplyChannel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReplyChannel)))
		i += copy(dAtA[i:], m.ReplyChannel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.CacheHit {
		dAtA[i] = 0x30
		i++
		if m.CacheHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Executed {
		dAtA[i] = 0x40
		i++
		if m.Executed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Span) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Span)))
		i += copy(dAtA[i:], m.Span)
	}
	return i, nil
}

func encodeVarintKubemqGo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedEmpty(r randyKubemqGo, easy bool) *Empty {
	this := &Empty{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResult(r randyKubemqGo, easy bool) *Result {
	this := &Result{}
	this.EventID = string(randStringKubemqGo(r))
	this.Sent = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEvent(r randyKubemqGo, easy bool) *Event {
	this := &Event{}
	this.EventID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v1 := r.Intn(100)
	this.Body = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.Store = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEventReceive(r randyKubemqGo, easy bool) *EventReceive {
	this := &EventReceive{}
	this.EventID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v2 := r.Intn(100)
	this.Body = make([]byte, v2)
	for i := 0; i < v2; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Sequence = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSubscribe(r randyKubemqGo, easy bool) *Subscribe {
	this := &Subscribe{}
	this.SubscribeTypeData = Subscribe_SubscribeType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Group = string(randStringKubemqGo(r))
	this.EventsStoreTypeData = Subscribe_EventsStoreType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	this.EventsStoreTypeValue = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.EventsStoreTypeValue *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRequest(r randyKubemqGo, easy bool) *Request {
	this := &Request{}
	this.RequestID = string(randStringKubemqGo(r))
	this.RequestTypeData = Request_RequestType([]int32{0, 1, 2}[r.Intn(3)])
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v3 := r.Intn(100)
	this.Body = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.ReplyChannel = string(randStringKubemqGo(r))
	this.Timeout = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Timeout *= -1
	}
	this.CacheKey = string(randStringKubemqGo(r))
	this.CacheTTL = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CacheTTL *= -1
	}
	v4 := r.Intn(100)
	this.Span = make([]byte, v4)
	for i := 0; i < v4; i++ {
		this.Span[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResponse(r randyKubemqGo, easy bool) *Response {
	this := &Response{}
	this.ClientID = string(randStringKubemqGo(r))
	this.RequestID = string(randStringKubemqGo(r))
	this.ReplyChannel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v5 := r.Intn(100)
	this.Body = make([]byte, v5)
	for i := 0; i < v5; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.CacheHit = bool(bool(r.Intn(2) == 0))
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Executed = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	v6 := r.Intn(100)
	this.Span = make([]byte, v6)
	for i := 0; i < v6; i++ {
		this.Span[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyKubemqGo interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneKubemqGo(r randyKubemqGo) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringKubemqGo(r randyKubemqGo) string {
	v7 := r.Intn(100)
	tmps := make([]rune, v7)
	for i := 0; i < v7; i++ {
		tmps[i] = randUTF8RuneKubemqGo(r)
	}
	return string(tmps)
}
func randUnrecognizedKubemqGo(r randyKubemqGo, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldKubemqGo(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldKubemqGo(dAtA []byte, r randyKubemqGo, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		v8 := r.Int63()
		if r.Intn(2) == 0 {
			v8 *= -1
		}
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(v8))
	case 1:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateKubemqGo(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Result) Size() (n int) {
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Sent {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func (m *Event) Size() (n int) {
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Store {
		n += 2
	}
	return n
}

func (m *EventReceive) Size() (n int) {
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.Sequence))
	}
	return n
}

func (m *Subscribe) Size() (n int) {
	var l int
	_ = l
	if m.SubscribeTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.SubscribeTypeData))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.EventsStoreTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.EventsStoreTypeData))
	}
	if m.EventsStoreTypeValue != 0 {
		n += 1 + sovKubemqGo(uint64(m.EventsStoreTypeValue))
	}
	return n
}

func (m *Request) Size() (n int) {
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.RequestTypeData))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ReplyChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timeout))
	}
	l = len(m.CacheKey)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.CacheTTL != 0 {
		n += 1 + sovKubemqGo(uint64(m.CacheTTL))
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ReplyChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.CacheHit {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Executed {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func sovKubemqGo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozKubemqGo(x uint64) (n int) {
	return sovKubemqGo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Result{`,
		`Id:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`Sent:` + fmt.Sprintf("%v", this.Sent) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Event) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Event{`,
		`Id:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Store:` + fmt.Sprintf("%v", this.Store) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EventReceive) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EventReceive{`,
		`Id:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Sequence:` + fmt.Sprintf("%v", this.Sequence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Subscribe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Subscribe{`,
		`SubscribeTypeData:` + fmt.Sprintf("%v", this.SubscribeTypeData) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Group:` + fmt.Sprintf("%v", this.Group) + `,`,
		`EventsStoreTypeData:` + fmt.Sprintf("%v", this.EventsStoreTypeData) + `,`,
		`EventsStoreTypeValue:` + fmt.Sprintf("%v", this.EventsStoreTypeValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`RequestTypeData:` + fmt.Sprintf("%v", this.RequestTypeData) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`ReplyChannel:` + fmt.Sprintf("%v", this.ReplyChannel) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`CacheKey:` + fmt.Sprintf("%v", this.CacheKey) + `,`,
		`CacheTTL:` + fmt.Sprintf("%v", this.CacheTTL) + `,`,
		`Span:` + fmt.Sprintf("%v", this.Span) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Response) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Response{`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ReplyChannel:` + fmt.Sprintf("%v", this.ReplyChannel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`CacheHit:` + fmt.Sprintf("%v", this.CacheHit) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Executed:` + fmt.Sprintf("%v", this.Executed) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`Span:` + fmt.Sprintf("%v", this.Span) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringKubemqGo(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sent = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Store = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReceive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReceive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReceive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscribe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscribe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscribe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscribeTypeData", wireType)
			}
			m.SubscribeTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscribeTypeData |= (Subscribe_SubscribeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsStoreTypeData", wireType)
			}
			m.EventsStoreTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventsStoreTypeData |= (Subscribe_EventsStoreType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsStoreTypeValue", wireType)
			}
			m.EventsStoreTypeValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventsStoreTypeValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeData", wireType)
			}
			m.RequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTypeData |= (Request_RequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTTL", wireType)
			}
			m.CacheTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheTTL |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = append(m.Span[:0], dAtA[iNdEx:postIndex]...)
			if m.Span == nil {
				m.Span = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheHit = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Executed = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = append(m.Span[:0], dAtA[iNdEx:postIndex]...)
			if m.Span == nil {
				m.Span = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKubemqGo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthKubemqGo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipKubemqGo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthKubemqGo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKubemqGo   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("kubemq_go.proto", fileDescriptor_kubemq_go_92930a2662292ba9) }

var fileDescriptor_kubemq_go_92930a2662292ba9 = []byte{
	// 914 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xbf, 0x93, 0xdb, 0x44,
	0x14, 0xd6, 0x4a, 0x96, 0x7f, 0x3c, 0xfb, 0xce, 0x7b, 0x7b, 0x9e, 0x8c, 0xc6, 0x64, 0xc4, 0xa1,
	0xca, 0x05, 0x38, 0xe1, 0x28, 0xa8, 0x32, 0x03, 0x77, 0xe7, 0x04, 0x26, 0x77, 0x30, 0x91, 0x2f,
	0xb4, 0x8c, 0x6c, 0x6f, 0xee, 0x34, 0xb1, 0xb4, 0x8a, 0xb4, 0x4a, 0x70, 0xc7, 0x9f, 0x40, 0x49,
	0x93, 0x8e, 0x82, 0x61, 0xf8, 0x03, 0x98, 0xe1, 0x1f, 0xa0, 0x4c, 0x07, 0x25, 0x27, 0x1a, 0xca,
	0x94, 0x94, 0xcc, 0xae, 0x7e, 0x58, 0x92, 0xed, 0x30, 0xa4, 0xdb, 0xef, 0xed, 0xfb, 0x9e, 0x3e,
	0xbf, 0xf7, 0xed, 0xae, 0xa1, 0xff, 0x34, 0x9e, 0x51, 0xef, 0xd9, 0xd7, 0x57, 0x6c, 0x1c, 0x84,
	0x8c, 0x33, 0xd2, 0x4c, 0x03, 0xc3, 0x0f, 0xae, 0x5c, 0x7e, 0x1d, 0xcf, 0xc6, 0x73, 0xe6, 0xdd,
	0xb9, 0x62, 0x57, 0xec, 0x8e, 0xdc, 0x9e, 0xc5, 0x4f, 0x24, 0x92, 0x40, 0xae, 0x52, 0x9a, 0xd5,
	0x02, 0x7d, 0xe2, 0x05, 0x7c, 0x65, 0x9d, 0x43, 0xd3, 0xa6, 0x51, 0xbc, 0xe4, 0xc4, 0x80, 0xd6,
	0xe4, 0x39, 0xf5, 0xf9, 0xe7, 0x67, 0x06, 0x3a, 0x42, 0xa3, 0x8e, 0x9d, 0x43, 0x42, 0xa0, 0x31,
	0xa5, 0x3e, 0x37, 0xd4, 0x23, 0x34, 0x6a, 0xdb, 0x72, 0x4d, 0x06, 0xa0, 0x4f, 0xc2, 0x90, 0x85,
	0x86, 0x26, 0x73, 0x53, 0x60, 0xbd, 0x44, 0xa0, 0x4b, 0xd6, 0x1b, 0xaa, 0x0d, 0xa1, 0x7d, 0xba,
	0x74, 0xd3, 0x2d, 0x55, 0x6e, 0x15, 0x58, 0xb0, 0x4e, 0xaf, 0x1d, 0xdf, 0xa7, 0xcb, 0xac, 0x6e,
	0x0e, 0x05, 0xeb, 0x82, 0x72, 0x67, 0xe1, 0x70, 0xc7, 0x68, 0xa4, 0xac, 0x1c, 0x0b, 0x7d, 0x27,
	0x6c, 0xb1, 0x32, 0xf4, 0x23, 0x34, 0xea, 0xd9, 0x72, 0x2d, 0xf4, 0x4d, 0x39, 0x0b, 0xa9, 0xd1,
	0x94, 0xa2, 0x53, 0x60, 0xfd, 0x8c, 0xa0, 0x27, 0x75, 0xd8, 0x74, 0x4e, 0xdd, 0xe7, 0xf4, 0x0d,
	0x32, 0x4b, 0x52, 0xd4, 0xdd, 0x52, 0xb4, 0x1d, 0x52, 0x1a, 0x25, 0x29, 0xb7, 0xa1, 0x73, 0xe9,
	0x7a, 0x34, 0xe2, 0x8e, 0x17, 0x48, 0x8d, 0x9a, 0xbd, 0x0e, 0x88, 0x6a, 0x53, 0xfa, 0x2c, 0xa6,
	0xfe, 0x3c, 0xd5, 0xda, 0xb0, 0x0b, 0x6c, 0xfd, 0xda, 0x80, 0xce, 0x34, 0x9e, 0x45, 0xf3, 0xd0,
	0x9d, 0x51, 0x72, 0x01, 0x07, 0x05, 0xb8, 0x5c, 0x05, 0xf4, 0x4c, 0x08, 0x10, 0xaa, 0xf7, 0x8f,
	0xdf, 0x1d, 0xa7, 0x36, 0x18, 0x17, 0x09, 0xe3, 0x4a, 0xaa, 0xbd, 0xc9, 0x7c, 0xcb, 0x39, 0x0c,
	0x40, 0x7f, 0x10, 0xb2, 0x38, 0xc8, 0x86, 0x90, 0x02, 0x32, 0x85, 0x43, 0xd9, 0xb7, 0x48, 0xb6,
	0xb9, 0x10, 0xa7, 0x4b, 0x71, 0xef, 0x6d, 0x8a, 0xab, 0x25, 0xdb, 0xdb, 0xd8, 0xe4, 0x18, 0x06,
	0xb5, 0xf0, 0x57, 0xce, 0x32, 0x4e, 0xbb, 0xa4, 0xd9, 0x5b, 0xf7, 0xac, 0x39, 0xec, 0x55, 0x7e,
	0x29, 0x19, 0xc2, 0xad, 0x4a, 0xe0, 0xb1, 0xbf, 0xa0, 0x4f, 0x5c, 0x9f, 0x2e, 0xb0, 0x42, 0x00,
	0x9a, 0x69, 0x11, 0x8c, 0x48, 0x1f, 0xba, 0xa5, 0x82, 0x58, 0x25, 0x3d, 0x68, 0x9f, 0x32, 0xcf,
	0x73, 0xfc, 0x45, 0x84, 0x35, 0xd2, 0x85, 0xd6, 0xa3, 0x98, 0x86, 0x2e, 0x8d, 0x70, 0xc3, 0xfa,
	0x01, 0x41, 0xbf, 0xf6, 0x75, 0x72, 0x1b, 0x8c, 0x5a, 0xa8, 0xfc, 0x25, 0x0c, 0xbd, 0x29, 0x77,
	0x42, 0xfe, 0x05, 0x7d, 0xf1, 0xa5, 0xbf, 0x5c, 0x61, 0x44, 0x08, 0xec, 0xcb, 0xc8, 0xfd, 0x90,
	0x79, 0xf7, 0xdd, 0x30, 0xe2, 0x58, 0x25, 0x07, 0xb0, 0x57, 0xc4, 0xce, 0x9d, 0x88, 0x63, 0x8d,
	0x1c, 0x42, 0x5f, 0x86, 0x3e, 0xe5, 0xb9, 0x29, 0x70, 0x43, 0x68, 0xcd, 0x82, 0xc2, 0x46, 0x58,
	0x27, 0x03, 0xc0, 0xa5, 0xc0, 0x19, 0x5d, 0x72, 0x07, 0x37, 0xad, 0x97, 0x1a, 0xb4, 0x6c, 0xc1,
	0x8a, 0xb8, 0xf0, 0x60, 0xb6, 0x2c, 0x9c, 0xbe, 0x0e, 0x90, 0x09, 0xf4, 0x33, 0x50, 0x8c, 0x4e,
	0x95, 0xa3, 0x7b, 0x27, 0x1f, 0x5d, 0xb6, 0x3d, 0x2e, 0xa5, 0xd9, 0x75, 0x4e, 0xc5, 0x51, 0xda,
	0x6e, 0x47, 0x35, 0x76, 0x1f, 0x27, 0x7d, 0xc7, 0x71, 0x6a, 0x96, 0x8e, 0x93, 0x05, 0x3d, 0x9b,
	0x06, 0xcb, 0x55, 0x5e, 0xae, 0x25, 0x39, 0x95, 0x98, 0xf8, 0x9a, 0xe8, 0x04, 0x8b, 0xb9, 0xd1,
	0x3e, 0x42, 0x23, 0xdd, 0xce, 0xa1, 0xd4, 0xe8, 0xcc, 0xaf, 0xe9, 0x43, 0xba, 0x32, 0x3a, 0x99,
	0xc6, 0x0c, 0x17, 0x7b, 0x97, 0x97, 0xe7, 0x06, 0x48, 0x5a, 0x81, 0xe5, 0x1d, 0x18, 0x38, 0xbe,
	0xd1, 0x4d, 0x95, 0x88, 0xb5, 0x75, 0x0f, 0xba, 0xa5, 0x16, 0x90, 0x5b, 0x40, 0x4a, 0xf0, 0xb1,
	0xff, 0xd4, 0x67, 0x2f, 0x7c, 0xac, 0x08, 0xef, 0x64, 0x4e, 0xc2, 0x88, 0x74, 0x40, 0x17, 0x46,
	0x5a, 0x61, 0xd5, 0xfa, 0x5e, 0x85, 0xb6, 0x4d, 0xa3, 0x80, 0xf9, 0x11, 0xad, 0xf4, 0x0e, 0xd5,
	0x7a, 0x57, 0x19, 0x9e, 0x5a, 0x1f, 0x5e, 0xbd, 0x1f, 0xda, 0x96, 0x7e, 0xfc, 0xdf, 0xdb, 0x33,
	0xef, 0xc4, 0x67, 0x2e, 0xcf, 0x2e, 0xd0, 0x02, 0x57, 0xaf, 0xb3, 0xd6, 0x96, 0xeb, 0x6c, 0xf2,
	0x0d, 0x9d, 0xc7, 0x9c, 0x2e, 0x64, 0xeb, 0xdb, 0x76, 0x81, 0xd7, 0x6f, 0x46, 0xa7, 0xf4, 0x66,
	0x14, 0x9d, 0x85, 0x75, 0x67, 0x8f, 0x7f, 0x57, 0x21, 0x7b, 0xd8, 0xc8, 0xfb, 0xd0, 0x99, 0x52,
	0x7f, 0x91, 0xbe, 0x2a, 0x7b, 0xb9, 0x1f, 0x25, 0x1c, 0xee, 0xaf, 0xed, 0x29, 0x9e, 0x30, 0x4b,
	0x21, 0x1f, 0x03, 0x2e, 0xb2, 0xa3, 0x29, 0x0f, 0xa9, 0xe3, 0xfd, 0x27, 0x69, 0x84, 0xee, 0x22,
	0xf2, 0x49, 0xf9, 0x72, 0x65, 0x29, 0x9f, 0x1c, 0x6c, 0xdc, 0x5c, 0xc3, 0x41, 0xa5, 0x58, 0xf6,
	0x8c, 0x58, 0xca, 0x5d, 0x44, 0xee, 0xc1, 0x61, 0xa9, 0x42, 0x36, 0x9f, 0xad, 0x35, 0xfa, 0xb5,
	0x53, 0x25, 0xe9, 0xc7, 0xd0, 0x15, 0xca, 0xf3, 0x03, 0x5b, 0xcf, 0x19, 0xe2, 0x92, 0x6c, 0x69,
	0x19, 0x4b, 0x21, 0x1f, 0x42, 0x2f, 0xe5, 0x64, 0x26, 0xda, 0xc8, 0x19, 0xae, 0x7f, 0xbb, 0x7c,
	0xed, 0x95, 0x93, 0x93, 0x57, 0x37, 0xa6, 0xf2, 0xc7, 0x8d, 0xa9, 0xbc, 0xbe, 0x31, 0xd1, 0x3f,
	0x37, 0x26, 0xfa, 0x36, 0x31, 0xd1, 0x8f, 0x89, 0x89, 0x7e, 0x49, 0x4c, 0xf4, 0x5b, 0x62, 0xa2,
	0x57, 0x89, 0x89, 0xfe, 0x4c, 0x4c, 0xf4, 0x77, 0x62, 0x2a, 0xaf, 0x13, 0x13, 0x7d, 0xf7, 0x97,
	0xa9, 0xfc, 0xa4, 0x76, 0x1f, 0xc6, 0x33, 0x7a, 0xf1, 0x68, 0xfc, 0x20, 0x0c, 0xe6, 0xb3, 0xa6,
	0xfc, 0x0f, 0xf1, 0xd1, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe3, 0x9a, 0x27, 0x3f, 0x8d, 0x08,
	0x00, 0x00,
}
